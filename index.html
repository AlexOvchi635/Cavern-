<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cavern</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 100%;
            max-height: 100%;
            background: #000;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #87CEEB 0%, #98D8E8 50%, #B0E0E6 100%);
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 15;
            display: none;
        }

        #scoreImage {
            width: auto;
            height: 40px;
            max-width: 150px;
            display: block;
        }

        #scoreText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 
                1px 1px 2px rgba(0, 0, 0, 0.8),
                0 0 4px rgba(0, 0, 0, 0.5);
            font-family: 'Arial', sans-serif;
            pointer-events: none;
            white-space: nowrap;
        }

        #highScore {
            display: none;
        }

        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            z-index: 20;
            pointer-events: auto;
            background: transparent;
            padding: 0;
            border-radius: 0;
            border: none;
            box-shadow: none;
        }

        #startScreen h1 {
            display: none;
        }

        #startScreen p {
            display: none;
        }

        #flagImage {
            position: absolute;
            top: 15vh;
            left: 50%;
            transform: translateX(-50%);
            width: min(70vw, 600px);
            height: auto;
            z-index: 20;
            display: block;
        }

        #startBtn {
            position: absolute;
            bottom: 12vh;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            padding: 0;
            background: none;
            border: none;
            cursor: pointer;
            pointer-events: auto;
            display: block;
            z-index: 21;
        }
        
        #startBtn img {
            display: block;
            width: min(65vw, 450px);
            height: auto;
        }
        
        #heroOnButton {
            position: absolute;
            bottom: calc(12vh + min(65vw, 450px) * 0.45);
            left: 50%;
            transform: translateX(-50%);
            z-index: 22;
            pointer-events: none;
            animation: heroJump 1s ease-in-out infinite;
        }
        
        #heroOnButton img {
            width: min(10vw, 70px);
            height: auto;
            display: block;
        }
        
        @keyframes heroJump {
            0% {
                transform: translate(-50%, -50%) translateY(0);
            }
            50% {
                transform: translate(-50%, -50%) translateY(-45px);
            }
            100% {
                transform: translate(-50%, -50%) translateY(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.9;
            }
        }


        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
            pointer-events: auto;
            display: none;
        }

        #gameOverTitle {
            font-size: 36px;
            margin-bottom: -100px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
            position: relative;
            top: -80px;
            cursor: pointer;
            pointer-events: auto;
            transition: opacity 0.2s;
            white-space: nowrap;
        }

        #gameOverTitle:hover {
            opacity: 0.8;
        }

        #gameOverTitle:active {
            opacity: 0.6;
        }

        #finalScoreContainer {
            position: relative;
            display: inline-block;
            margin-bottom: -60px;
            transform: translateY(60px);
        }

        #finalScoreImage {
            width: auto;
            height: 60px;
            max-width: 200px;
            display: block;
        }

        #finalScore {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 
                1px 1px 2px rgba(0, 0, 0, 0.8),
                0 0 4px rgba(0, 0, 0, 0.5);
            font-family: 'Arial', sans-serif;
            pointer-events: none;
            white-space: nowrap;
        }


        .hidden {
            display: none !important;
        }

        #controls {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 150px;
            z-index: 15;
            pointer-events: auto;
        }

        .controlBtn {
            width: 84px;
            height: 84px;
            border-radius: 50%;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            backdrop-filter: none;
            transition: all 0.1s;
            position: relative;
            overflow: visible;
        }

        .controlBtn img {
            width: 130%;
            height: 130%;
            object-fit: cover;
            pointer-events: none;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .controlBtn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.5);
        }

        @media (max-width: 500px) {
            #gameContainer {
                max-width: 100%;
                max-height: 100%;
            }
            
            #startScreen h1 {
                font-size: 36px;
            }
            
            #score {
                top: 8px;
                right: 8px;
            }

            #scoreImage {
                height: 30px;
                max-width: 120px;
            }

            #scoreText {
                font-size: 14px;
            }

            #gameOverTitle {
                font-size: 28px;
                margin-bottom: 20px;
            }

            #finalScoreImage {
                height: 45px;
                max-width: 150px;
            }

            #finalScore {
                font-size: 18px;
            }

            
            #highScore {
                font-size: 18px;
            }
            
            #flagImage {
                top: 12vh;
                width: 75vw;
            }
            
            #startBtn {
                bottom: 10vh;
            }
            
            #startBtn img {
                width: 70vw;
            }
            
            #heroOnButton {
                bottom: calc(10vh + 70vw * 0.45);
            }
            
            #heroOnButton img {
                width: 55px;
            }
        }
        
        /* Специальные стили для Telegram Mini App (маленькие экраны) */
        @media (max-height: 800px) {
            #flagImage {
                top: 10vh;
                width: min(70vw, 550px);
            }
            
            #startBtn {
                bottom: 8vh;
            }
            
            #startBtn img {
                width: min(65vw, 400px);
            }
            
            #heroOnButton {
                bottom: calc(8vh + min(65vw, 400px) * 0.45);
            }
            
            #heroOnButton img {
                width: min(9vw, 55px);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    <div id="ui">
            <div id="score">
                <img id="scoreImage" src="https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeiheenqd6cs75o5bmf7rgxeoat6hojd7d5ncxi57dqz5gs3kenjfxe" alt="Score">
                <span id="scoreText">0</span>
            </div>
            <div id="highScore">Рекорд: 0</div>
            <div id="controls">
                <div class="controlBtn" id="leftBtn">
                    <img src="https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeifugsuqinrxkfkgzccckpnmuppp33zvl5blydhynjf6qgxt3n73si" alt="Влево">
                </div>
                <div class="controlBtn" id="rightBtn">
                    <img src="https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeihexo7w6x4nr4nb57gard3mtz6wpq7ujwrwgldwdjc76rwkenaclu" alt="Вправо">
                </div>
            </div>
        </div>
        <img id="flagImage" src="https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeia3jddld5twkyc2732263ghj7vwnbea7axpyhbsaxgaufz7oppism" alt="Флаг">
        <button id="startBtn">
            <img src="https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafkreifubhfsu2mte54zfod244cz4smwk4yqlnf6lphwtfqatqyeal2wwe" alt="Начать игру">
        </button>
        <div id="heroOnButton">
            <img src="https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeie5cezd2vxdqdnqynqstkh5tjmenuruoc3pg2i65hx2gsxenojy7y" alt="Герой">
        </div>
        <div id="startScreen">
            <h1>Cavern</h1>
            <p>Используйте стрелки или кнопки<br>для управления</p>
            <p>Прыгайте на платформы<br>и поднимайтесь выше!</p>
    </div>
    <div id="gameOver">
        <h2 id="gameOverTitle">Game Over</h2>
        <div id="finalScoreContainer">
            <img id="finalScoreImage" src="https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeiheenqd6cs75o5bmf7rgxeoat6hojd7d5ncxi57dqz5gs3kenjfxe" alt="Score">
            <span id="finalScore">0</span>
        </div>
    </div>
    </div>

    <script>
        // Telegram WebApp инициализация
        let tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const scoreTextEl = document.getElementById('scoreText');
        const highScoreEl = document.getElementById('highScore');
        const gameOverEl = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');

        // Настройка canvas
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Игровые переменные
        let gameState = 'start'; // start, playing, gameOver
        let highScore = 0;
        let score = 0;
        let cameraY = 0;
        let highestPlayerY = 0; // Максимальная высота, на которую поднялся игрок (минимальное значение player.y)
        
        // Спрайт огня от реактивного ранца
        
        // Фоновое изображение
        const backgroundImage = new Image();
        backgroundImage.src = 'https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeifwinisuha2cu7hwmmfa7wyt5nl2ullhmwnvv4q5swdv7s6krmt7y';
        let backgroundLoaded = false;
        backgroundImage.onload = () => {
            backgroundLoaded = true;
        };

        // Изображения персонажа
        const playerImageLeft = new Image(); // Персонаж смотрит влево
        playerImageLeft.src = 'https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeibs3byjdd3tmqt4fod5ll6x7om3qqjgtsoicgayqr2g2e4qftez7a';
        let playerImageLeftLoaded = false;
        playerImageLeft.onload = () => {
            playerImageLeftLoaded = true;
            updatePlayerSize();
        };

        const playerImageRight = new Image(); // Персонаж смотрит вправо
        playerImageRight.src = 'https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeie5cezd2vxdqdnqynqstkh5tjmenuruoc3pg2i65hx2gsxenojy7y';
        let playerImageRightLoaded = false;
        playerImageRight.onload = () => {
            playerImageRightLoaded = true;
            updatePlayerSize();
        };

        // Функция обновления размера персонажа
        function updatePlayerSize() {
            if (playerImageLeftLoaded || playerImageRightLoaded) {
                const img = playerImageLeftLoaded ? playerImageLeft : playerImageRight;
                // Увеличиваем размер персонажа
                const maxWidth = 60; // Было 50
                const maxHeight = 70; // Было 60
                const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
                player.width = img.width * scale;
                player.height = img.height * scale;
            }
        }

        // Спрайты платформ
        const platformImage = new Image(); // Обычная платформа
        let platformImageLoaded = false;
        platformImage.onload = () => {
            platformImageLoaded = true;
            console.log('Платформа загружена:', platformImage.width, 'x', platformImage.height);
        };
        platformImage.onerror = (e) => {
            console.error('Ошибка загрузки изображения платформы:', e);
            platformImageLoaded = false;
        };
        // Загружаем изображение
        platformImage.src = 'https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeignsx6nwrqdfykr5tkqcmbsqkve42uz5mvgmrrrtu46gf7vrqbxbm';

        const movingPlatformImage = new Image(); // Движущаяся платформа (используем тот же спрайт)
        let movingPlatformImageLoaded = false;
        movingPlatformImage.onload = () => {
            movingPlatformImageLoaded = true;
        };
        movingPlatformImage.onerror = (e) => {
            console.error('Ошибка загрузки изображения движущейся платформы:', e);
            movingPlatformImageLoaded = false;
        };
        // Используем тот же спрайт что и для обычных платформ
        movingPlatformImage.src = 'https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeignsx6nwrqdfykr5tkqcmbsqkve42uz5mvgmrrrtu46gf7vrqbxbm';

        // Игрок
        const player = {
            x: 0,
            y: 0,
            width: 40,
            height: 50,
            velocityX: 0,
            velocityY: 0,
            onPlatform: false,
            hasJetpack: false,
            jetpackStartTime: 0, // Время активации ранца (в миллисекундах)
            immunityEndTime: 0, // Время окончания иммунитета (в миллисекундах)
            monstersHiddenUntil: 0, // Время до которого монстры скрыты
            jetpacksHiddenUntil: 0 // Время до которого ранцы скрыты
        };

        // Платформы
        let platforms = [];
        const PLATFORM_WIDTH = 90; // Уменьшено с 120 до 90
        const PLATFORM_HEIGHT = 25; // Уменьшено с 30 до 25
        const PLATFORM_SPACING = 70;
        
        // Система секторов для разных типов платформ
        const SECTOR_HEIGHT = 1000; // Высота сектора в пикселях (уменьшено для более частой смены)
        let currentSector = 0; // Текущий сектор
        let platformGroups = []; // Группы платформ для группового движения

        // Изображения монстров
        const monsterImageLeft = new Image(); // Монстр смотрит влево
        monsterImageLeft.src = 'https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeib37u73k7k33uxlemsj6ubwn5kzrc55w4ba72dc2ocsv5ea7cyzuy';
        let monsterImageLeftLoaded = false;
        monsterImageLeft.onload = () => {
            monsterImageLeftLoaded = true;
        };

        const monsterImageRight = new Image(); // Монстр смотрит вправо
        monsterImageRight.src = 'https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeihi27typfofxqqlsbcq5nucomggj6asbfdbk6da64jpmgj5y4bbai';
        let monsterImageRightLoaded = false;
        monsterImageRight.onload = () => {
            monsterImageRightLoaded = true;
        };

        // Препятствия (монстры)
        let monsters = [];
        let hiddenMonsters = []; // Временно скрытые монстры
        const MONSTER_SIZE = 50; // Немного уменьшен (было 66)

        // Спрайт реактивного ранца
        const jetpackImage = new Image();
        jetpackImage.src = 'https://aquamarine-past-gamefowl-916.mypinata.cloud/ipfs/bafybeiegyn7ctgc7rtrvwo36ivhfttxxjsqz75qd6ze2awcwxxer5lzkdi';
        let jetpackImageLoaded = false;
        jetpackImage.onload = () => {
            jetpackImageLoaded = true;
        };

        // Реактивные ранцы
        let jetpacks = [];
        let hiddenJetpacks = []; // Временно скрытые ранцы
        const JETPACK_SIZE = 40;

        // Пружины
        let springs = [];
        const SPRING_SIZE = 25;

        // Физика
        const GRAVITY = 0.24; // 0.3 * 0.8 (замедлено на 20%)
        const JUMP_POWER = -8;
        const SPRING_POWER = -15; // Возвращено на прежнее значение
        const JETPACK_POWER = -0.64; // -0.8 * 0.8 (замедлено на 20%)
        const MAX_SPEED = 6; // Возвращено на прежнее значение
        const ACCELERATION = 1.0; // Возвращено на прежнее значение
        const FRICTION = 0.88;

        // Управление
        let keys = {};
        let touchLeft = false;
        let touchRight = false;

        // Загрузка рекорда
        function loadHighScore() {
            if (tg?.initDataUnsafe?.user?.id) {
                const saved = localStorage.getItem(`highScore_${tg.initDataUnsafe.user.id}`);
                highScore = saved ? parseInt(saved) : 0;
            } else {
                highScore = parseInt(localStorage.getItem('highScore') || '0');
            }
            highScoreEl.textContent = `Рекорд: ${highScore}`;
        }

        // Сохранение рекорда
        function saveHighScore() {
            if (score > highScore) {
                highScore = score;
                if (tg?.initDataUnsafe?.user?.id) {
                    localStorage.setItem(`highScore_${tg.initDataUnsafe.user.id}`, highScore.toString());
                } else {
                    localStorage.setItem('highScore', highScore.toString());
                }
                highScoreEl.textContent = `Рекорд: ${highScore}`;
            }
        }

        // Инициализация игры
        function initGame() {
            gameState = 'playing';
            score = 0;
            platforms = [];
            monsters = [];
            jetpacks = [];
            springs = [];
            hiddenMonsters = [];
            hiddenJetpacks = [];

            // Стартовая позиция игрока в мировых координатах
            // Игрок должен быть виден на 70% высоты экрана
            const startPlayerWorldY = 0;
            player.x = canvas.width / 2 - player.width / 2;
            player.y = startPlayerWorldY;
            player.velocityX = 0;
            player.velocityY = 0;
            player.onPlatform = false;
            highestPlayerY = startPlayerWorldY; // Сбрасываем максимальную высоту
            player.hasJetpack = false;
            player.jetpackStartTime = 0;
            player.immunityEndTime = 0;
            player.monstersHiddenUntil = 0;
            player.jetpacksHiddenUntil = 0;
            hiddenMonsters = [];
            hiddenJetpacks = [];
            player.facingRight = false; // Начальное направление

            // Настройка камеры так, чтобы игрок был виден на 70% высоты экрана
            cameraY = startPlayerWorldY - canvas.height * 0.7;

            // Создание стартовой платформы прямо под игроком
            platforms.push({
                x: canvas.width / 2 - PLATFORM_WIDTH / 2,
                y: startPlayerWorldY + player.height,
                width: PLATFORM_WIDTH,
                height: PLATFORM_HEIGHT,
                type: 'normal',
                moveDirection: 1,
                moveSpeed: 2,
                spriteIndex: 0 // Можно выбрать 0 или 1
            });

            // Создание начальных платформ выше (уменьшено количество, так как платформы стали больше)
            for (let i = 1; i < 50; i++) {
                createPlatform(startPlayerWorldY - i * PLATFORM_SPACING);
            }

            // Создание начальных бонусов (равномерное распределение)
            // Враги отключены
            let jetpackCounter = 0;
            for (let i = 5; i < 50; i++) {
                const y = startPlayerWorldY - i * PLATFORM_SPACING;
                
                // Ранец каждые 10 платформ
                jetpackCounter++;
                if (jetpackCounter >= 10) {
                    createJetpack(y);
                    jetpackCounter = 0;
                }
                // Пружины скрыты
            }

            startScreen.classList.add('hidden');
            const flagImage = document.getElementById('flagImage');
            const startBtn = document.getElementById('startBtn');
            const heroOnButton = document.getElementById('heroOnButton');
            if (flagImage) flagImage.style.display = 'none';
            if (startBtn) startBtn.style.display = 'none';
            if (heroOnButton) heroOnButton.style.display = 'none';
            gameOverEl.style.display = 'none';
            // Показываем счет во время игры
            scoreEl.style.display = 'block';
            scoreTextEl.textContent = '0';
            // Показываем кнопки управления во время игры
            const controlsEl = document.getElementById('controls');
            if (controlsEl) controlsEl.style.display = 'flex';
        }

        // Определение типа сектора (какой тип платформ генерировать)
        function getSectorType(y) {
            const sectorIndex = Math.floor(Math.abs(y) / SECTOR_HEIGHT);
            const sectorPattern = sectorIndex % 8; // 8 типов секторов для разнообразия
            
            // Начинаем сразу со сложных секторов для интересной игры
            switch(sectorPattern) {
                case 0: return 'mixEasy'; // Простой микс: 80% обычных, 20% движущихся
                case 1: return 'mixMedium'; // Средний микс: 60% обычных, 30% движущихся, 10% fading
                case 2: return 'oneTouch'; // Сектор с одноразовыми платформами
                case 3: return 'mixHard'; // Сложный микс: 40% обычных, 30% движущихся, 20% одноразовых, 10% fading
                case 4: return 'fading'; // Сектор с исчезающими платформами (3 касания)
                case 5: return 'mixMedium'; // Средний микс
                case 6: return 'mixHard'; // Сложный микс
                case 7: return 'oneTouch'; // Сектор с одноразовыми платформами
                default: return 'mixMedium'; // По умолчанию средний микс
            }
        }
        
        // Создание платформы
        function createPlatform(y, forceType = null) {
            // Определяем тип платформы на основе сектора
            const sectorType = forceType || getSectorType(y);
            let platformType = 'normal';
            let specialProps = {};
            
            // Определяем тип платформы в зависимости от сектора
            if (sectorType === 'normal') {
                // Обычный сектор - только обычные платформы
                platformType = 'normal';
            } else if (sectorType === 'oneTouch') {
                // В секторе одноразовых платформ - только они
                platformType = 'oneTouch';
                specialProps = {
                    touched: false,
                    disappearsImmediately: true
                };
            } else if (sectorType === 'fading') {
                // В секторе исчезающих платформ - только они (3 касания)
                platformType = 'fading';
                specialProps = {
                    maxTouches: 3,
                    currentTouches: 0,
                    opacity: 1.0
                };
            } else if (sectorType === 'breaking') {
                // Breaking сектор больше не используется - обычные платформы
                platformType = 'normal';
            } else if (sectorType === 'mixEasy') {
                // Простой микс: 80% обычных, 20% движущихся
                const rand = Math.random();
                if (rand < 0.2) {
                    platformType = 'moving';
                } else {
                    platformType = 'normal';
                }
            } else if (sectorType === 'mixMedium') {
                // Средний микс: 60% обычных, 30% движущихся, 10% fading
                const rand = Math.random();
                if (rand < 0.3) {
                    platformType = 'moving';
                } else if (rand < 0.4) {
                    platformType = 'fading';
                    specialProps = {
                        maxTouches: 3,
                        currentTouches: 0,
                        opacity: 1.0
                    };
                } else {
                    platformType = 'normal';
                }
            } else if (sectorType === 'mixHard') {
                // Сложный микс: 40% обычных, 30% движущихся, 20% одноразовых, 10% fading
                const rand = Math.random();
                if (rand < 0.3) {
                    platformType = 'moving';
                } else if (rand < 0.5) {
                    platformType = 'oneTouch';
                    specialProps = {
                        touched: false,
                        disappearsImmediately: true
                    };
                } else if (rand < 0.6) {
                    platformType = 'fading';
                    specialProps = {
                        maxTouches: 3,
                        currentTouches: 0,
                        opacity: 1.0
                    };
                } else {
                    platformType = 'normal';
                }
            } else {
                // Fallback - обычная платформа
                platformType = 'normal';
            }
            
            // Равномерное распределение платформ по всей ширине экрана
            // Платформы разбросаны по всем углам и краям карты
            const platformX = Math.random() * (canvas.width - PLATFORM_WIDTH);
            
            const platform = {
                x: platformX,
                y: y,
                width: PLATFORM_WIDTH,
                height: PLATFORM_HEIGHT,
                type: platformType,
                moveDirection: Math.random() < 0.5 ? 1 : -1,
                moveSpeed: 2,
                ...specialProps
            };
            
            platforms.push(platform);
            return platform;
        }

        // Создание монстра
        function createMonster(y) {
            monsters.push({
                x: Math.random() * (canvas.width - MONSTER_SIZE),
                y: y - 40,
                size: MONSTER_SIZE,
                moveDirection: Math.random() < 0.5 ? 1 : -1,
                moveSpeed: 1.5
            });
        }

        // Создание реактивного ранца
        function createJetpack(y) {
            jetpacks.push({
                x: Math.random() * (canvas.width - JETPACK_SIZE),
                y: y - 40,
                size: JETPACK_SIZE
            });
        }

        // Создание пружины
        function createSpring(y) {
            springs.push({
                x: Math.random() * (canvas.width - SPRING_SIZE),
                y: y - 15,
                size: SPRING_SIZE
            });
        }

        // Обработка управления
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Кнопки управления
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchLeft = true;
        });
        leftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchLeft = false;
        });
        leftBtn.addEventListener('mousedown', () => touchLeft = true);
        leftBtn.addEventListener('mouseup', () => touchLeft = false);
        leftBtn.addEventListener('mouseleave', () => touchLeft = false);

        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchRight = true;
        });
        rightBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchRight = false;
        });
        rightBtn.addEventListener('mousedown', () => touchRight = true);
        rightBtn.addEventListener('mouseup', () => touchRight = false);
        rightBtn.addEventListener('mouseleave', () => touchRight = false);

        // Обновление игры
        function update() {
            if (gameState !== 'playing') return;

            // Управление
            let isMoving = false;
            if (keys['ArrowLeft'] || keys['a'] || keys['A'] || touchLeft) {
                player.velocityX -= ACCELERATION;
                player.facingRight = false; // Смотрим влево
                isMoving = true;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D'] || touchRight) {
                player.velocityX += ACCELERATION;
                player.facingRight = true; // Смотрим вправо
                isMoving = true;
            }

            // Ограничение скорости
            player.velocityX = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, player.velocityX));
            
            // Трение применяется только когда игрок не двигается
            if (!isMoving) {
                player.velocityX *= FRICTION;
            }

            // Обновление позиции игрока
            player.x += player.velocityX;

            // Выход за границы экрана (телепортация)
            if (player.x < -player.width) {
                player.x = canvas.width;
            } else if (player.x > canvas.width) {
                player.x = -player.width;
            }

            // ПОДБОР РАНЦА ДО ОБНОВЛЕНИЯ ФИЗИКИ (чтобы топливо устанавливалось правильно)
            // Подбор реактивного ранца
            for (let jetpack of jetpacks) {
                if (player.x + player.width > jetpack.x &&
                    player.x < jetpack.x + jetpack.size &&
                    player.y + player.height > jetpack.y &&
                    player.y < jetpack.y + jetpack.size) {
                    // Реактивный ранец: 2 секунды
                    // СТРОГО: проверяем, можно ли подобрать ранец
                    const currentTime = Date.now();
                    let canPickup = false;
                    
                    // СТРОГО: проверяем состояние ранца
                    if (!player.hasJetpack) {
                        // Ранец не активен - можно подобрать
                        canPickup = true;
                    } else if (player.jetpackStartTime > 0) {
                        // Ранец активен - проверяем, прошло ли 2 секунды
                        const elapsed = currentTime - player.jetpackStartTime;
                        canPickup = (elapsed >= 2000);
                        console.log('Проверка подбора ранца: elapsed =', elapsed, 'canPickup =', canPickup);
                    } else {
                        // hasJetpack = true, но время не установлено - можно подобрать (исправляем состояние)
                        canPickup = true;
                    }
                    
                    if (canPickup) {
                        // Устанавливаем ранец
                        player.hasJetpack = true;
                        player.jetpackStartTime = currentTime; // Запоминаем время активации
                        
                        // СКРЫВАЕМ все монстры и ранцы на время полета + 5 секунд после
                        const hideUntil = currentTime + 2000 + 5000; // 2 секунды полета + 5 секунд после
                        player.monstersHiddenUntil = hideUntil;
                        player.jetpacksHiddenUntil = hideUntil;
                        
                        // Перемещаем монстры и ранцы во временное хранилище
                        hiddenMonsters = [...monsters];
                        hiddenJetpacks = [...jetpacks];
                        monsters = [];
                        jetpacks = [];
                        
                        console.log('РАНЕЦ ПОДОБРАН! Монстры и ранцы скрыты до:', hideUntil);
                        break; // Подобрали ранец, выходим из цикла
                    } else {
                        // Ранец уже активен - удаляем объект, чтобы не подобрать его снова
                        jetpacks = jetpacks.filter(j => j !== jetpack);
                        break;
                    }
                }
            }

            // Реактивный ранец (2 секунды) - СТРОГАЯ ПРОВЕРКА
            const updateTime = Date.now();
            
            // ВОССТАНАВЛИВАЕМ монстры и ранцы если прошло время скрытия
            if (updateTime >= player.monstersHiddenUntil && hiddenMonsters.length > 0) {
                monsters = [...hiddenMonsters];
                hiddenMonsters = [];
                player.monstersHiddenUntil = 0;
            }
            if (updateTime >= player.jetpacksHiddenUntil && hiddenJetpacks.length > 0) {
                jetpacks = [...hiddenJetpacks];
                hiddenJetpacks = [];
                player.jetpacksHiddenUntil = 0;
            }
            
            // СТРОГО: проверяем и отключаем ранец если нужно
            if (player.hasJetpack) {
                    // СТРОГО: если время не установлено - ОТКЛЮЧАЕМ СРАЗУ
                if (player.jetpackStartTime <= 0) {
                    console.log('РАНЕЦ ОТКЛЮЧЕН! Время не установлено');
                    player.hasJetpack = false;
                    player.jetpackStartTime = 0;
                    player.velocityY += GRAVITY;
                } else {
                    // СТРОГО: вычисляем прошедшее время
                    const elapsed = updateTime - player.jetpackStartTime;
                    
                    // СТРОГО: если прошло >= 2000 мс - ОТКЛЮЧАЕМ
                    if (elapsed >= 2000) {
                        console.log('РАНЕЦ ОТКЛЮЧЕН! elapsed:', elapsed);
                        player.hasJetpack = false;
                        player.jetpackStartTime = 0;
                        player.immunityEndTime = updateTime + 5000;
                        player.velocityY += GRAVITY;
                    } else {
                        // Ранец активен - применяем силу
                        player.velocityY += JETPACK_POWER;
                    }
                }
            } else {
                // Ранец не активен - гравитация
                // СТРОГО: сбрасываем время если ранец не активен
                if (player.jetpackStartTime > 0) {
                    player.jetpackStartTime = 0;
                }
                player.velocityY += GRAVITY;
            }

            player.y += player.velocityY;
            player.onPlatform = false;

            // Столкновение с платформами
            for (let i = platforms.length - 1; i >= 0; i--) {
                const platform = platforms[i];
                
                // Движущиеся платформы
                if (platform.type === 'moving') {
                    platform.x += platform.moveSpeed * platform.moveDirection;
                    if (platform.x < 0 || platform.x > canvas.width - platform.width) {
                        platform.moveDirection *= -1;
                    }
                }

                // Проверка столкновения (в мировых координатах)
                if (player.velocityY > 0 &&
                    player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + platform.height + 10) {
                    
                    // Обычные платформы и другие типы - дают прыжок
                    player.y = platform.y - player.height;
                    player.velocityY = JUMP_POWER;
                    player.onPlatform = true;
                    
                    // Обработка специальных типов платформ
                    if (platform.type === 'oneTouch') {
                        // Одноразовая платформа - исчезает СРАЗУ при касании, но дает прыжок
                        platforms.splice(i, 1);
                    } else if (platform.type === 'fading') {
                        // Платформа с ограниченными касаниями
                        platform.currentTouches = (platform.currentTouches || 0) + 1;
                        platform.opacity = 1.0 - (platform.currentTouches / platform.maxTouches) * 0.8;
                        if (platform.currentTouches >= platform.maxTouches) {
                            platforms.splice(i, 1);
                        }
                    }
                }
            }

            // Пружины скрыты (не обрабатываем столкновения)

            // Столкновение с монстрами - ОТКЛЮЧЕНО
            // Враги временно удалены из игры

            // Обновление камеры (следует за игроком вверх)
            if (player.y < cameraY + canvas.height * 0.3) {
                cameraY = player.y - canvas.height * 0.3;
            }
            // Камера также следует вниз, если игрок падает
            if (player.y > cameraY + canvas.height * 0.7) {
                cameraY = player.y - canvas.height * 0.7;
            }

            // Обновление счета (основано на высоте подъема)
            const newScore = Math.max(0, Math.floor((0 - player.y) / 10));
            if (newScore > score) {
                score = newScore;
                scoreTextEl.textContent = score;
            }

            // Вычисляем высоту игрока для динамической сложности
            // Чем выше, тем меньше платформ и сложнее
            // player.y уменьшается при подъеме (отрицательные значения), поэтому инвертируем
            const playerHeight = Math.max(0, -player.y); // Высота от старта
            const difficultyLevel = Math.floor(playerHeight / 1000); // Уровень сложности каждые 1000 пикселей
            
            // Количество платформ уменьшается с высотой (базовое 35, минимум 18)
            const platformsToGenerate = Math.max(18, 35 - difficultyLevel);
            // Расстояние между платформами увеличивается с высотой (базовое 70, максимум 95)
            const currentSpacing = Math.min(95, 70 + difficultyLevel * 3);
            
            // Генерация новых платформ выше игрока
            if (platforms.length > 0) {
                const highestPlatform = Math.min(...platforms.map(p => p.y));
                if (highestPlatform > player.y - 1000) {
                    // Сначала генерируем все основные платформы
                    for (let i = 1; i <= platformsToGenerate; i++) {
                        createPlatform(highestPlatform - i * currentSpacing);
                    }
                    
                }
            }

            // Генерация новых бонусов выше игрока (независимо от платформ)
            const allY = [player.y - 500];
            platforms.forEach(p => allY.push(p.y));
            // if (monsters.length > 0) allY.push(...monsters.map(m => m.y)); // Монстры отключены
            if (jetpacks.length > 0) allY.push(...jetpacks.map(j => j.y));
            
            const highestY = Math.min(...allY);
            
            // Проверяем, есть ли иммунитет (ранец активен или недавно закончился)
            const currentTime = Date.now();
            let hasActiveJetpack = false;
            if (player.hasJetpack && player.jetpackStartTime > 0) {
                const elapsed = currentTime - player.jetpackStartTime;
                hasActiveJetpack = (elapsed < 2000);
            }
            const hasImmunity = hasActiveJetpack || (player.immunityEndTime > 0 && currentTime < player.immunityEndTime);
            
            // Если есть иммунитет, генерируем монстров и бустеры выше текущей позиции игрока
            const minGenerationY = hasImmunity ? player.y - 800 : player.y - 1500;
            
            if (highestY > minGenerationY) {
                // Генерируем монстров и бусты независимо от платформ
                // Чем выше, тем больше монстров (каждые 3-4 платформы - больше монстров)
                const monsterInterval = Math.max(3, 5 - Math.floor(difficultyLevel / 2));
                // Ранцы остаются каждые 10 платформ
                const jetpackInterval = 10;
                
                let monsterCounter = 0;
                let jetpackCounter = 0;
                
                // Генерируем на большей высоте, чтобы не пропадали
                // Если есть иммунитет, начинаем генерацию выше текущей позиции игрока
                const startY = hasImmunity ? player.y - 800 : highestY;
                
                for (let i = 1; i <= platformsToGenerate + 5; i++) {
                    const y = startY - i * currentSpacing;
                    
                    // Монстры отключены - генерация временно отключена
                    
                    // Ранец каждые 10 платформ (равномерно) - только если не скрыты
                    if (currentTime >= player.jetpacksHiddenUntil) {
                        jetpackCounter++;
                        if (jetpackCounter >= jetpackInterval) {
                            createJetpack(y);
                            jetpackCounter = 0;
                        }
                    }
                    // Пружины скрыты
                }
            }

            // Удаление объектов за пределами экрана (внизу)
            platforms = platforms.filter(p => p.y < cameraY + canvas.height + 1000);
            // monsters = monsters.filter(m => m.y < cameraY + canvas.height + 1000); // Монстры отключены
            jetpacks = jetpacks.filter(j => j.y < cameraY + canvas.height + 1000);
            springs = springs.filter(s => s.y < cameraY + canvas.height + 1000);

            // Проигрыш (падение вниз за пределы экрана)
            const playerScreenY = player.y - cameraY;
            
            // Проверяем, есть ли платформы ниже игрока в видимой области
            let hasPlatformsBelow = false;
            
            // Проверяем, есть ли хотя бы одна платформа ниже игрока в видимой области
            for (let platform of platforms) {
                const platformScreenY = platform.y - cameraY;
                // Платформа видна и находится ниже игрока
                if (platformScreenY > playerScreenY && 
                    platformScreenY < canvas.height + 50 &&
                    platformScreenY > -50) {
                    hasPlatformsBelow = true;
                    break;
                }
            }
            
            // Если игрок падает вниз и нет платформ ниже него в видимой области - игра заканчивается
            if (player.velocityY > 0 && !hasPlatformsBelow && playerScreenY > canvas.height * 0.3) {
                gameOver();
                return;
            }
            
            // Дополнительная проверка: если игрок упал ниже нижней границы экрана
            if (playerScreenY > canvas.height) {
                gameOver();
                return;
            }
            
            // Дополнительная проверка: если игрок упал ниже стартовой позиции
            // (на случай, если камера не успевает следовать или игрок поднялся очень высоко)
            if (player.y > 200) {
                gameOver();
                return;
            }
        }

        // Отрисовка
        function draw() {
            // Очистка экрана
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Фон (изображение или градиент как fallback) - статичный, не двигается
            if (backgroundLoaded && backgroundImage.complete) {
                // Статичный фон - сохраняем пропорции, заполняем весь экран (cover)
                const bgWidth = backgroundImage.width;
                const bgHeight = backgroundImage.height;
                const canvasAspect = canvas.width / canvas.height;
                const bgAspect = bgWidth / bgHeight;
                
                let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
                
                if (bgAspect > canvasAspect) {
                    // Изображение шире - подгоняем по высоте
                    drawHeight = canvas.height;
                    drawWidth = bgWidth * (canvas.height / bgHeight);
                    offsetX = (canvas.width - drawWidth) / 2;
                } else {
                    // Изображение выше - подгоняем по ширине
                    drawWidth = canvas.width;
                    drawHeight = bgHeight * (canvas.width / bgWidth);
                    offsetY = (canvas.height - drawHeight) / 2;
                }
                
                ctx.drawImage(backgroundImage, offsetX, offsetY, drawWidth, drawHeight);
            } else {
                // Fallback: градиент пока изображение загружается
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.5, '#98D8E8');
                gradient.addColorStop(1, '#B0E0E6');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Облака (декорация) - только если нет фона
                drawClouds();
            }

            // Игровые объекты - только если игра началась
            if (gameState === 'playing') {
                // Реактивные ранцы (рисуем ПЕРЕД платформами и монстрами, чтобы не залезали на них)
                for (let jetpack of jetpacks) {
                    const screenY = jetpack.y - cameraY;
                    if (screenY > -50 && screenY < canvas.height + 50) {
                        if (jetpackImageLoaded && jetpackImage.complete) {
                            // Рисуем изображение ранца с сохранением пропорций
                            const aspectRatio = jetpackImage.height / jetpackImage.width;
                            const drawWidth = jetpack.size;
                            const drawHeight = jetpack.size * aspectRatio;
                            
                            // Эффект свечения/сияния
                            const glowIntensity = 0.6 + 0.4 * Math.sin(Date.now() / 200); // Пульсирующее свечение
                            
                            // Рисуем несколько слоев свечения
                            for (let i = 3; i > 0; i--) {
                                ctx.globalAlpha = glowIntensity * (i / 3) * 0.3;
                                ctx.shadowBlur = 15 + i * 5;
                                ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
                                ctx.drawImage(
                                    jetpackImage, 
                                    jetpack.x - i * 2, 
                                    screenY - i * 2, 
                                    drawWidth + i * 4, 
                                    drawHeight + i * 4
                                );
                            }
                            
                            // Основное изображение
                            ctx.globalAlpha = 1.0;
                            ctx.shadowBlur = 0;
                            ctx.drawImage(jetpackImage, jetpack.x, screenY, drawWidth, drawHeight);
                        } else {
                            // Fallback: простой прямоугольник пока изображение загружается
                            ctx.fillStyle = '#FF4444';
                            ctx.fillRect(jetpack.x, screenY, jetpack.size, jetpack.size * 1.2);
                            ctx.fillStyle = '#FF8800';
                            ctx.fillRect(jetpack.x + 5, screenY + 5, jetpack.size - 10, jetpack.size * 1.2 - 10);
                        }
                    }
                }

                // Платформы
                for (let platform of platforms) {
                    const screenY = platform.y - cameraY;
                    if (screenY > -100 && screenY < canvas.height + 100) {
                        // Применяем прозрачность для платформ
                        if (platform.type === 'fading' && platform.opacity !== undefined) {
                            ctx.globalAlpha = platform.opacity;
                        } else if (platform.type === 'oneTouch') {
                            // Одноразовые платформы - полупрозрачные
                            ctx.globalAlpha = 0.5;
                        } else {
                            ctx.globalAlpha = 1.0;
                        }
                        
                        // Определяем цвет/спрайт в зависимости от типа платформы
                        let platformColor = '#4CAF50'; // Зеленый - обычная
                        let useSprite = false;
                        let sprite = platformImage;
                        
                        if (platform.type === 'moving') {
                            platformColor = '#FF6B6B'; // Красный - движущаяся
                            useSprite = movingPlatformImageLoaded && movingPlatformImage.complete && movingPlatformImage.width > 0;
                            sprite = movingPlatformImage;
                        } else if (platform.type === 'oneTouch') {
                            platformColor = '#FF4444'; // Ярко-красный - одноразовая
                            useSprite = platformImageLoaded && platformImage.complete && platformImage.width > 0;
                        } else if (platform.type === 'fading') {
                            platformColor = '#8888FF'; // Синий - исчезающая
                            useSprite = platformImageLoaded && platformImage.complete && platformImage.width > 0;
                        } else {
                            useSprite = platformImageLoaded && platformImage.complete && platformImage.width > 0 && platformImage.height > 0;
                        }
                        
                        if (useSprite && sprite) {
                            const spriteWidth = sprite.width;
                            const spriteHeight = sprite.height;
                            
                            // Тайлинг текстуры по ширине платформы
                            const tiles = Math.ceil(platform.width / spriteWidth);
                            for (let i = 0; i < tiles; i++) {
                                const x = platform.x + (i * spriteWidth);
                                const drawWidth = Math.min(spriteWidth, platform.x + platform.width - x);
                                ctx.drawImage(
                                    sprite,
                                    0, 0, spriteWidth, spriteHeight, // источник (полное изображение)
                                    x, screenY, drawWidth, platform.height // назначение
                                );
                            }
                        } else {
                            // Fallback: цветной прямоугольник пока спрайт загружается
                            ctx.fillStyle = platformColor;
                            ctx.fillRect(platform.x, screenY, platform.width, platform.height);
                            ctx.strokeStyle = '#2E7D32';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(platform.x, screenY, platform.width, platform.height);
                            
                            // Визуальные индикаторы для специальных типов
                            if (platform.type === 'oneTouch') {
                                // Красный крестик для одноразовой
                                ctx.strokeStyle = '#FFFFFF';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(platform.x + 10, screenY + 10);
                                ctx.lineTo(platform.x + platform.width - 10, screenY + platform.height - 10);
                                ctx.moveTo(platform.x + platform.width - 10, screenY + 10);
                                ctx.lineTo(platform.x + 10, screenY + platform.height - 10);
                                ctx.stroke();
                            }
                        }
                        
                        ctx.globalAlpha = 1.0; // Возвращаем нормальную прозрачность
                    }
                }

                // Пружины скрыты (не рисуем)

                // Монстры - ОТКЛЮЧЕНЫ
                // Отрисовка монстров временно отключена

                // Игрок (преобразование мировых координат в экранные)
                const playerScreenY = player.y - cameraY;
                
                // Голубое сияние вокруг героя при активном ранце
                const drawTime = Date.now();
                let hasActiveJetpack = false;
                if (player.hasJetpack && player.jetpackStartTime > 0) {
                    const elapsed = drawTime - player.jetpackStartTime;
                    hasActiveJetpack = (elapsed < 2000);
                }
                const hasImmunity = hasActiveJetpack || (player.immunityEndTime > 0 && drawTime < player.immunityEndTime);
                
                if (hasActiveJetpack || hasImmunity) {
                    // Эффект яркого голубого свечения (круглое)
                    const glowIntensity = 0.8 + 0.2 * Math.sin(Date.now() / 120);
                    
                    // Рисуем несколько слоев свечения (круг) - меньший радиус и более прозрачное
                    for (let i = 4; i > 0; i--) {
                        ctx.globalAlpha = glowIntensity * (i / 4) * 0.3; // Более прозрачное
                        ctx.shadowBlur = 15 + i * 5;
                        ctx.shadowColor = 'rgba(135, 206, 250, 0.8)'; // Более прозрачное свечение
                        ctx.beginPath();
                        ctx.arc(
                            player.x + player.width / 2, 
                            playerScreenY + player.height / 2, 
                            (player.width / 2) + i * 5, 
                            0, 
                            Math.PI * 2
                        );
                        ctx.fillStyle = `rgba(135, 206, 250, ${0.2 + i * 0.05})`;
                        ctx.fill();
                    }
                    
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                }
                
                // Выбираем спрайт в зависимости от направления (поменяли местами)
                const currentPlayerImage = player.facingRight ? playerImageLeft : playerImageRight;
                const currentPlayerImageLoaded = player.facingRight ? playerImageLeftLoaded : playerImageRightLoaded;
                
                if (currentPlayerImageLoaded && currentPlayerImage.complete) {
                    // Мерцание персонажа при активном ранце
                    if (hasActiveJetpack) {
                        const flicker = 0.6 + 0.4 * Math.sin(Date.now() / 100); // Быстрое мерцание
                        ctx.globalAlpha = flicker;
                    } else {
                        ctx.globalAlpha = 1.0;
                    }
                    
                    // Рисуем изображение персонажа
                    ctx.drawImage(currentPlayerImage, player.x, playerScreenY, player.width, player.height);
                    
                    ctx.globalAlpha = 1.0; // Возвращаем нормальную прозрачность
                } else {
                    // Fallback: простой прямоугольник пока изображение загружается
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(player.x, playerScreenY, player.width, player.height);
                    // Лицо игрока
                    ctx.fillStyle = '#000';
                    // Глаза
                    ctx.fillRect(player.x + 10, playerScreenY + 12, 6, 6);
                    ctx.fillRect(player.x + 24, playerScreenY + 12, 6, 6);
                    // Рот
                    ctx.beginPath();
                    ctx.arc(player.x + player.width / 2, playerScreenY + 30, 8, 0, Math.PI);
                    ctx.stroke();
                }

                // Реактивный ранец - СТРОГАЯ ПРОВЕРКА ДЛЯ АНИМАЦИИ
                const currentTime = Date.now();
                
                // СТРОГО: проверяем время и отключаем ранец если нужно
            }
            
        }

        // Рисование облаков
        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            for (let i = 0; i < 5; i++) {
                const cloudX = (i * 200 + (cameraY * 0.1) % 1000) % (canvas.width + 200) - 100;
                const cloudY = (i * 150 - cameraY * 0.05) % (canvas.height + 200);
                drawCloud(cloudX, cloudY);
            }
        }

        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 25, y, 30, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        // Игровой цикл
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Конец игры
        function gameOver() {
            gameState = 'gameOver';
            saveHighScore();
            finalScoreEl.textContent = score;
            gameOverEl.style.display = 'block';
            // Скрываем счет при окончании игры
            scoreEl.style.display = 'none';
            // Скрываем кнопки управления при окончании игры
            const controlsEl = document.getElementById('controls');
            if (controlsEl) controlsEl.style.display = 'none';
        }

        // Обработчики кнопок
        startBtn.addEventListener('click', initGame);
        gameOverTitle.addEventListener('click', initGame);

        // Загрузка рекорда при старте
        loadHighScore();

        // Запуск игрового цикла
        gameLoop();
    </script>
</body>
</html>
